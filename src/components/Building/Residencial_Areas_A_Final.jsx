/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/Residencial_Areas.glb 
*/

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { annotation3d, residenceTogglesAtom } from "../UI";
import { useAtom } from "jotai";
// import { CameraModes, useCharacterCustomization } from '../../contexts/CustomizationContext'

export const tipologiasResidencias = [
  "2BR_G_A",
  "2BR_G_B",
  "2BR_N1_A",
  "2BR_N1_B",
  "2BR_N2_A",
  "2BR_N2_B",
  "3BR_G_A",
  "3BR_G_B",
  "3BR_N1_A",
  "3BR_N1_B",
  "3BR_N2_A",
  "3BR_N2_B",
  "4BR_A",
  "4BR_B",
];

const ResidencialAreasA = (props) => {
  const { nodes, materials } = useGLTF("./models/Residencial_Areas_A.glb");
  // const { tipologyResidencias, setTipologyResidencias, cameraMode, setCameraMode } = useCharacterCustomization()

  const [annotation] = useAtom(annotation3d);
  const [residenceToggles] = useAtom(residenceTogglesAtom);

  //State for hover scaling
  const [hoveredMesh, setHoveredMesh] = useState(null);

  //Refs for each mesh
  const meshRefs = useRef({});

  //Refs for materials to handle opacity
  const materialRefs = useRef({});

  //Effect to handle opacity and color changes
  useEffect(() => {
    Object.keys(materialRefs.current).forEach((meshName) => {
      const material = materialRefs.current[meshName];
      if (material) {
        if (hoveredMesh === meshName) {
          material.opacity = 0.8;
          // material.emissive.set(0xffffff) // White emissive for bright white effect
          material.emissive.copy(material.originalEmissive);
          material.emissiveIntensity = 0.3;
          material.needsUpdate = true;
        } else {
          material.opacity = 0.45; // Restaurar la transparencia base de 0.75
          material.emissive.copy(material.originalEmissive); // Restore original emissive
          material.emissiveIntensity = 0;
          material.needsUpdate = true;
        }
        material.transparent = true;
      }
    });
  }, [hoveredMesh]);

  // // Handle hover events
  // const handlePointerOver = (meshName) => {

  // Handle hover events with stopPropagation to avoid bubbling into overlapped meshes
  const handlePointerEnter = (meshName, event) => {
    event.stopPropagation?.();

    setHoveredMesh(meshName);
    document.body.style.cursor = "pointer";
  };

  // const handlePointerOut = () => {

  const handlePointerLeave = (event) => {
    event.stopPropagation?.();

    setHoveredMesh(null);
    document.body.style.cursor = "default";
  };

  // Mapping de objetos a imagenes y titulos
  const objectMappings = {
    "2BR_G_A": {
      image: "./FP/2BR_A.jpg",
      title: "2 Bedrooms A Garden: 211.54 sqm",
    },
    "2BR_N1_A": {
      image: "./FP/2BR_A.jpg",
      title: "2 Bedrooms A L1: 211.54.00 sqm",
    },
    "2BR_N2_A": {
      image: "./FP/2BR_A.jpg",
      title: "2 Bedrooms A L2: 211.54.00 sqm",
    },
    "3BR_G_A": {
      image: "./FP/3BR_A.jpg",
      title: "3 Bedrooms A Garden: 215.71 sqm",
    },
    "3BR_N1_A": {
      image: "./FP/3BR_A.jpg",
      title: "3 Bedrooms A L1: 215.71 sqm",
    },
    "3BR_N2_A": {
      image: "./FP/3BR_A.jpg",
      title: "3 Bedrooms A L2: 215.71 sqm",
    },
    "4BR_A": { image: "./FP/4BR_A.jpg", title: "4 Bedrooms A: 428.86 sqm" },
  };

  // Handle click to active amenities camera
  // const handleClick = (objectName) => {
  const handleClick = (objectName, event) => {
    event?.stopPropagation?.();
    // setCameraMode(CameraModes.RESIDENCES)

    // Disparar evento para mostrar floating panel con informacion especifica del objeto
    const mapping = objectMappings[objectName];
    if (mapping) {
      // window.dispatchEvent(new CustomEvent('annotation-click', {
      window.dispatchEvent(
        new CustomEvent("mesh-click", {
          detail: {
            image: mapping.image,
            annotation: mapping.title,
            // meshName: objectName
            // meshName: objectName,
            // source: 'mesh'
          },
        }),
      );
    }
  };

  // // Clone material to handle opacity and color changes
  // const getMaterial = (baseMaterial, meshName) => {

  // Clone material to handle opacity and allow optional color override per mesh
  const getMaterial = (baseMaterial, meshName, colorOverride) => {
    if (!materialRefs.current[meshName]) {
      const clonedMaterial = baseMaterial.clone();
      clonedMaterial.transparent = true;

      clonedMaterial.depthWrite = true; // keep depth buffer for proper occlusion
      clonedMaterial.depthTest = true;

      clonedMaterial.opacity = 0.75; // Establecer transparencia de 0.75
      clonedMaterial.originalColor = clonedMaterial.color.clone(); // Store original color
      clonedMaterial.originalEmissive = clonedMaterial.emissive.clone(); //Store original emissive

      // Optional: override base color from the mesh config
      if (colorOverride) {
        clonedMaterial.color.set(colorOverride);
      }

      materialRefs.current[meshName] = clonedMaterial;
    }
    return materialRefs.current[meshName];
  };

  // useEffect(() => {
  //   setTipologyResidencias(tipologiasResidencias)
  // }, [tipologiasResidencias])

  // const tipoCheck = (tipologia) => {
  //   return cameraMode === CameraModes.RESIDENCES && tipologyResidencias.includes(tipologia)
  // }

  const tipoCheck = (tipologia, residenceType) => {
    if (annotation === "residences") {
      if (residenceType && residenceToggles[residenceType]) {
        return true;
      }
      return false;
    }
    return false;
  };

  return (
    <group {...props} dispose={null}>
      <mesh
        ref={(el) => (meshRefs.current["2BR_G_A"] = el)}
        geometry={nodes.R_2BR_G_F.geometry}
        // material={getMaterial(materials['Material_2.012'], '2BR_G_A', '#9C9284')}
        material={getMaterial(
          materials["Material_2.012"],
          "2BR_G_A",
          "#2E3641",
        )}
        visible={tipoCheck("2BR_G_A", "2 Bedroom Garden")}
        scale={hoveredMesh === "2BR_G_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('2BR_G_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("2BR_G_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("2BR_G_A", event)}
      >
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_2BR_G_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>

      <mesh
        ref={(el) => (meshRefs.current["2BR_N1_A"] = el)}
        geometry={nodes.R_2BR_N1_F.geometry}
        // material={getMaterial(materials['Material_2.013'], '2BR_N1_A', '#67849A')}
        material={getMaterial(
          materials["Material_2.013"],
          "2BR_N1_A",
          "#2E3641",
        )}
        visible={tipoCheck("2BR_N1_A", "2 Bedroom")}
        scale={hoveredMesh === "2BR_N1_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('2BR_N1_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("2BR_N1_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("2BR_N1_A", event)}
      >
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_2BR_N1_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>

      <mesh
        ref={(el) => (meshRefs.current["2BR_N2_A"] = el)}
        geometry={nodes.R_2BR_N2_F.geometry}
        // material={getMaterial(materials['Material_2.013'], '2BR_N2_A', '#67849A')}
        material={getMaterial(
          materials["Material_2.013"],
          "2BR_N2_A",
          "#2E3641",
        )}
        visible={tipoCheck("2BR_N2_A", "2 Bedroom")}
        scale={hoveredMesh === "2BR_N2_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('2BR_N2_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("2BR_N2_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("2BR_N2_A", event)}
      >
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_2BR_N2_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>

      <mesh
        ref={(el) => (meshRefs.current["3BR_G_A"] = el)}
        geometry={nodes.R_3BR_G_F.geometry}
        // material={getMaterial(materials['Material_2.012'], '3BR_G_A', '#2F3640')}
        material={getMaterial(
          materials["Material_2.012"],
          "3BR_G_A",
          "#2E3641",
        )}
        visible={tipoCheck("3BR_G_A", "3 Bedroom Garden")}
        scale={hoveredMesh === "3BR_G_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('3BR_G_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("3BR_G_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("3BR_G_A", event)}
      >
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_3BR_G_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>

      <mesh
        ref={(el) => (meshRefs.current["3BR_N1_A"] = el)}
        geometry={nodes.R_3BR_N1_F.geometry}
        // material={getMaterial(materials['Material_2.013'], '3BR_N1_A', '#DCE5EA')}
        material={getMaterial(
          materials["Material_2.013"],
          "3BR_N1_A",
          "#2E3641",
        )}
        visible={tipoCheck("3BR_N1_A", "3 Bedroom")}
        scale={hoveredMesh === "3BR_N1_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('3BR_N1_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("3BR_N1_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("3BR_N1_A", event)}
      >
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_3BR_N1_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>

      <mesh
        ref={(el) => (meshRefs.current["3BR_N2_A"] = el)}
        geometry={nodes.R_3BR_N2_F.geometry}
        // material={getMaterial(materials['Material_2.013'], '3BR_N2_A', '#DCE5EA')}
        material={getMaterial(
          materials["Material_2.013"],
          "3BR_N2_A",
          "#2E3641",
        )}
        visible={tipoCheck("3BR_N2_A", "3 Bedroom")}
        scale={hoveredMesh === "3BR_N2_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('3BR_N2_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("3BR_N2_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("3BR_N2_A", event)}
      >
        {/* ★ EDGES (bordes externos sin inner edges) */}
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_3BR_N2_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>

      <mesh
        ref={(el) => (meshRefs.current["4BR_A"] = el)}
        geometry={nodes.R_4BR_F.geometry}
        // material={getMaterial(materials['Material_2.012'], '4BR_A', '#E8E2DB')}
        material={getMaterial(materials["Material_2.012"], "4BR_A", "#2E3641")}
        visible={tipoCheck("4BR_A", "4 Bedroom")}
        scale={hoveredMesh === "4BR_A" ? 1.003 : 1}
        // onPointerOver={() => handlePointerOver('4BR_A')}
        // onPointerOut={handlePointerOut}

        onPointerEnter={(event) => handlePointerEnter("4BR_A", event)}
        onPointerLeave={handlePointerLeave}
        onClick={(event) => handleClick("4BR_A", event)}
      >
        {/* ★ EDGES (bordes externos sin inner edges) */}
        {/* <lineSegments scale={1.001}> */}

        <lineSegments scale={1.001} raycast={() => null}>
          <edgesGeometry args={[nodes.R_4BR_F.geometry, Math.PI]} />
          <lineBasicMaterial color="#C3C3C3" transparent opacity={0.9} />
        </lineSegments>
      </mesh>
    </group>
  );
};

useGLTF.preload("./models/Residencial_Areas_A.glb");

export default ResidencialAreasA;
